package runtimelogs

import (
	"github.com/fabric8-analytics/poc-ocp-upgrade-prediction/pkg/serviceparser"
	"github.com/fabric8-analytics/poc-ocp-upgrade-prediction/pkg/utils"
	"github.com/golang-collections/collections/stack"
	"go.uber.org/zap"
	"regexp"
	"strings"
)

var logger, _ = zap.NewDevelopment()
var slogger = logger.Sugar()

// RuntimeLogEntry is our internal representation the runtime log of a program.
type RuntimeLogEntry struct {
	Operation string `json:"operation"`
	Filename string `json:"filename"`
	Lineno string `json:"lineno"`
	TestFlowName string `json:"test_flow_name"`
	Funcname string `json:"funcname"`
}

// ParseComponentE2ELogs parses the logs that are generated by the "make test-e2e" command in Openshift.
func ParseComponentE2ELogs(testLog []string) (map[string][]RuntimeLogEntry, error) {
	pattern := regexp.MustCompile(`\[\s*\d\s*]\s*(?P<opn>EXIT|ENTER):\s*(?P<filename>\S*):(?P<lno>\d*)\s*(?P<fname>[a-zA-z0-9]*)`)
	logs := make(map[string][]RuntimeLogEntry)
	testName := "Pre test setup"

	for _, logEntry := range testLog {
		slogger.Debugf("log entry: %s", strings.TrimSpace(logEntry))
		matches := utils.ReSubMatchMap(pattern, logEntry)

		if matches == nil {
			// Not one of the logs from tracey
			testNameFinder := regexp.MustCompile(`^=*\s*(?P<status>RUN|PASS)\s*(?P<testName>\S*)\n*$`)
			matches = utils.ReSubMatchMap(testNameFinder, logEntry)

			if matches != nil {
				if tname, ok := matches["testName"]; ok {
					testName  = tname
					slogger.Debugf("Test name changed to: %v\n", testName)
				}
			}
			continue
		}
		if fnName, ok := matches["fname"]; ok {
			logs[testName] = append(logs[testName], RuntimeLogEntry{
				Operation: matches["opn"],
				Filename: matches["filename"],
				Lineno: matches["lno"],
				TestFlowName: testName,
				Funcname: fnName,
			})
		}
	}

	return logs, nil
}


// CreateRuntimePaths creates the runtime path entries in the graph.
func CreateRuntimePaths(logPath string) ([]serviceparser.CodePath){
	fileData, err := utils.ReadFileLines(logPath)
	if err != nil {
		slogger.Errorf("Failed to read end to end test log, error: %v\n", err)
	}
	logPaths, err := ParseComponentE2ELogs(fileData)

	if err != nil {
		slogger.Errorf("Failed to parse component end to end logs, got error: %v\n", err)
	}

	var runtimePaths []serviceparser.CodePath
	for testName, logList := range logPaths {

		callStack := stack.New()
		for _, logEntry := range logList {
			if logEntry.Operation == "ENTER" {
				callStack.Push(&logEntry)
			} else {
				fnCallee, _ := callStack.Pop().(*RuntimeLogEntry)
				fnCaller, _ := callStack.Pop().(*RuntimeLogEntry)

				if fnCaller == nil {
					// Self loop path
					runtimePaths = append(runtimePaths, serviceparser.CodePath{
						From: fnCallee.Funcname,
						To: fnCallee.Funcname,
						PathType:"runtime_path",
						PathAttrs: map[string]string{
							"TestFlow": testName,
						},
						SelectorCallee:"",
						ContainerPackage: serviceparser.FilePackageMap[fnCallee.Filename],
					})
					// no need to push back.
				} else {
					// real path
					runtimePaths = append(runtimePaths, serviceparser.CodePath{
						From: fnCaller.Funcname,
						To: fnCallee.Funcname,
						PathType:"runtime_path",
						PathAttrs: map[string]string{
							"TestFlow": testName,
						},
						SelectorCallee:"",
						ContainerPackage: serviceparser.FilePackageMap[fnCallee.Filename],
					})
					// push back caller
					callStack.Push(fnCaller)
				}
			}
		}
	}
	return runtimePaths
}