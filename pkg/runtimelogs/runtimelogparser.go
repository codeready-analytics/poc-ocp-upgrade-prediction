//runtimelogs parses the runtimelogs of the COMPONENT level end to end tests for an operator, and not the extended (product) end to end
// tests that live inside the origin repository.
package runtimelogs

import (
	"regexp"

	"github.com/fabric8-analytics/poc-ocp-upgrade-prediction/pkg/serviceparser"
	"github.com/fabric8-analytics/poc-ocp-upgrade-prediction/pkg/utils"
	"github.com/golang-collections/collections/stack"
	"go.uber.org/zap"
)

var logger, _ = zap.NewDevelopment()
var slogger = logger.Sugar()

// RuntimeLogEntry is our internal representation the runtime log of a program.
type RuntimeLogEntry struct {
	Operation    string `json:"operation"`
	Filename     string `json:"filename"`
	Lineno       string `json:"lineno"`
	TestFlowName string `json:"test_flow_name"`
	Funcname     string `json:"funcname"`
}

// ParseComponentE2ELogs parses the logs that are generated by the "make test-e2e" command in Openshift.
func ParseComponentE2ELogs(testLog []string) (map[string][]RuntimeLogEntry, error) {
	pattern := regexp.MustCompile(`\[\s*\d\s*]\s*(?P<opn>EXIT|ENTER):\s*(?P<filename>\S*):(?P<lno>\d*)\s*(?P<fname>[a-zA-z0-9]*)`)
	logs := make(map[string][]RuntimeLogEntry)
	testName := "Pre test setup"

	for _, logEntry := range testLog {
		matches := utils.ReSubMatchMap(pattern, logEntry)

		if matches == nil {
			// Not one of the logs from tracey
			testNameFinder := regexp.MustCompile(`^=*\s*(?P<status>RUN|PASS)\s*(?P<testName>\S*)\n*$`)
			matches = utils.ReSubMatchMap(testNameFinder, logEntry)

			if matches != nil {
				if tname, ok := matches["testName"]; ok {
					testName = tname
				}
			}
			continue
		}
		if fnName, ok := matches["fname"]; ok {
			logs[testName] = append(logs[testName], RuntimeLogEntry{
				Operation:    matches["opn"],
				Filename:     matches["filename"],
				Lineno:       matches["lno"],
				TestFlowName: testName,
				Funcname:     fnName,
			})
		}
	}

	return logs, nil
}

// CreateRuntimePaths creates the runtime path entries in the graph.
func CreateRuntimePaths(logs interface{}, components *serviceparser.ServiceComponents) []serviceparser.CodePath {
	var fileData []string
	logFileStr, isFilePath := logs.(string)
	if isFilePath {
		// Can't define in := fashion becuase fileData is overridden.
		var err error
		fileData, err = utils.ReadFileLines(logFileStr)
		if err != nil {
			slogger.Errorf("Failed to read end to end test log, error: %v\n", err)
		}
	} else {
		logContent, ok := logs.([]string)
		if !ok {
			slogger.Errorf("Log content is neither filepath nor list of strings.")
		}
		fileData = logContent
	}
	logPaths, err := ParseComponentE2ELogs(fileData)

	if err != nil {
		slogger.Errorf("Failed to parse component end to end logs, got error: %v\n", err)
	}

	var runtimePaths []serviceparser.CodePath
	for testName, logList := range logPaths {

		callStack := stack.New()
		for _, logEntry := range logList {
			if logEntry.Operation == "ENTER" {
				callStack.Push(logEntry)
			} else if logEntry.Operation == "EXIT" {
				el := callStack.Pop()
				fnCallee, ok := el.(RuntimeLogEntry)
				if !ok {
					// Stack was emptied
					continue
				}

				el = callStack.Pop()
				fnCaller, ok := el.(RuntimeLogEntry)

				if !ok {
					// Self loop path because empty stack
					runtimePaths = append(runtimePaths, serviceparser.CodePath{
						From:     fnCallee.Funcname,
						To:       fnCallee.Funcname,
						PathType: "runtime_path",
						PathAttrs: map[string]string{
							"TestFlow": testName,
						},
						SelectorCallee:         "",
						ContainerPackage:       components.FilePackageMap[fnCallee.Filename],
						ContainerPackageCaller: components.FilePackageMap[fnCallee.Filename],
					})
					// no need to push back.
				} else {
					// real path
					runtimePaths = append(runtimePaths, serviceparser.CodePath{
						From:     fnCaller.Funcname,
						To:       fnCallee.Funcname,
						PathType: "runtime_path",
						PathAttrs: map[string]string{
							"TestFlow": testName,
						},
						SelectorCallee:         "",
						ContainerPackage:       components.FilePackageMap[fnCallee.Filename],
						ContainerPackageCaller: components.FilePackageMap[fnCaller.Filename],
					})
					// push back caller
					callStack.Push(fnCaller)
				}
			}
		}
	}

	return runtimePaths
}
