package utils

import (
	"os"
	"testing"
)


func TestGetServiceVersion(t *testing.T) {
	type args struct {
		dirpath string
	}
	tests := []struct {
		name string
		args args
	}{
		{
			name: "Test git service version",
			args: args{
				dirpath: ".",
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := GetServiceVersion(tt.args.dirpath); got == "" {
				t.Errorf("GetServiceVersion() = %v", got)
			}
		})
	}
}

func Test_IsGeneratedCode(t *testing.T) {
	type args struct {
		fileContent string
	}
	tests := []struct {
		name string
		args args
		want bool
	}{
		{
			name: "Test generated content regexp no-match.",
			args: args{
				fileContent: `package bindata
				
				import (
				   "fmt"
				   "io/ioutil"
				   "os"
				   "path/filepath"
				   "strings"
				   "time"
			   )`,
			},
			want: false,
		},
		{
			name: "Test generated content regexp match.",
			args: args{
				fileContent: `// Code generated by go-bindata.
				 // sources:
				 // pkg/operator/staticpod/controller/installer/manifests/installer-pod.yaml
				 // DO NOT EDIT!
				
				 package bindata
				
				 import (
				    "fmt"
			        "io/ioutil"
			        "os"
			        "path/filepath"
			        "strings"
			        "time"
			    )`,
			},
			want: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := IsGeneratedCode(tt.args.fileContent); got != tt.want {
				t.Errorf("isGeneratedCode() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestIsIgnoredFileName(t *testing.T) {
	type args struct {
		builddir string
		filename string
	}
	tests := []struct {
		name string
		args args
		want bool
	}{
		{
			name: "Test whether _linux is ignored.",
			args: args{
				builddir: "./testdata/buildcontext/",
				filename: "compile_linux.go",
			},
			want: false,
		},
		{
			name: "Test whether darwin is ignored.",
			args: args{
				builddir: "./testdata/buildcontext/",
				filename: "compile_darwin.go",
			},
			want: true,
		},
		{
			name: "Test whether _linux is ignored.",
			args: args{
				builddir: "./testdata/buildcontext/",
				filename: "compile_darwin_amd64.go",
			},
			want: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := IsIgnoredFileName(tt.args.builddir, tt.args.filename); got != tt.want {
				t.Errorf("IsIgnoredFileName() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestIsRestrictedDir(t *testing.T) {
	type args struct {
		dirname string
	}
	tests := []struct {
		name string
		args args
		want bool
	}{
		{
			name: "Test .git directory is ignored",
			args: args{
				dirname: ".git",
			},
			want: true,
		},
		{
			name: "Test tests directory is ignored",
			args: args{
				dirname: "test",
			},
			want: true,
		},
		{
			name: "Test a generic directory is not ignored",
			args: args{
				dirname: "lolnogenerics",
			},
			want: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := IsRestrictedDir(tt.args.dirname); got != tt.want {
				t.Errorf("IsRestrictedDir() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestIsGeneratedCode(t *testing.T) {
	type args struct {
		fileContent string
	}
	tests := []struct {
		name string
		args args
		want bool
	}{
		{
			name: "Test positive case",
			args: args{
				fileContent: `// +build !ignore_autogenerated

/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by deepcopy-gen. DO NOT EDIT.

package v1beta1`,
			},
			want: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := IsGeneratedCode(tt.args.fileContent); got != tt.want {
				t.Errorf("IsGeneratedCode() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestLoadDirectoriesToExclude(t *testing.T) {
	os.Setenv("PATCH_SKIP_FOLDER_LIST_FILE", "./testdata/ignore-dirs-for-patching.txt")
	tests := []struct {
		name string
	}{
		{
			name:"Check if skip folder list works.",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := LoadDirectoriesToExclude(); got == nil {
				t.Errorf("LoadDirectoriesToExclude() returned nil.")
			}
		})
	}
}

func TestIsIgnoredFile(t *testing.T) {
	type args struct {
		filePath string
	}
	tests := []struct {
		name string
		args args
		want bool
	}{
		{
			name: "Test if ignore list is used to ignore directories.",
			args: args{
				filePath: "somefilepath/vendor",
			},
			want: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := IsIgnoredFile(tt.args.filePath); got != tt.want {
				t.Errorf("IsIgnoredFile() = %v, want %v", got, tt.want)
			}
		})
	}
}