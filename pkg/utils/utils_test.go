package utils

import (
	"os"
	"testing"
)

func TestRunCloneShell(t *testing.T) {
	type args struct {
		repo     string
		destdir  string
		branch   string
		revision string
	}
	tests := []struct {
		name string
		args args
		want string
	}{
		{
			name: "Test git clone at revision",
			args: args{
				repo:     "https://github.com/openshift/machine-config-operator",
				destdir:  "/tmp",
				branch:   "master",
				revision: "287504634d7a52a605d2c7f7c46f93f281368915",
			},
			want: "/tmp/src/github.com/openshift/machine-config-operator",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, cloned := RunCloneShell(tt.args.repo, tt.args.destdir, tt.args.branch, tt.args.revision)
			_, err := os.Stat(got)
			if err != nil || !cloned {
				t.Errorf("Clone failed.")
			}
			if got != tt.want {
				t.Errorf("Wanted: %v\n, Got: %v\n", tt.want, got)
			}
			_ = os.Remove(got)
		})
	}
}

func TestGetServiceVersion(t *testing.T) {
	type args struct {
		dirpath string
	}
	tests := []struct {
		name string
		args args
	}{
		{
			name: "Test git service version",
			args: args{
				dirpath: ".",
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := GetServiceVersion(tt.args.dirpath); got == "" {
				t.Errorf("GetServiceVersion() = %v", got)
			}
		})
	}
}

func Test_IsGeneratedCode(t *testing.T) {
	type args struct {
		fileContent string
	}
	tests := []struct {
		name string
		args args
		want bool
	}{
		{
			name: "Test generated content regexp no-match.",
			args: args{
				fileContent: `package bindata
				
				import (
				   "fmt"
				   "io/ioutil"
				   "os"
				   "path/filepath"
				   "strings"
				   "time"
			   )`,
			},
			want: false,
		},
		{
			name: "Test generated content regexp match.",
			args: args{
				fileContent: `// Code generated by go-bindata.
				 // sources:
				 // pkg/operator/staticpod/controller/installer/manifests/installer-pod.yaml
				 // DO NOT EDIT!
				
				 package bindata
				
				 import (
				    "fmt"
			        "io/ioutil"
			        "os"
			        "path/filepath"
			        "strings"
			        "time"
			    )`,
			},
			want: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := IsGeneratedCode(tt.args.fileContent); got != tt.want {
				t.Errorf("isGeneratedCode() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestIsIgnoredFileName(t *testing.T) {
	type args struct {
		builddir string
		filename string
	}
	tests := []struct {
		name string
		args args
		want bool
	}{
		{
			name: "Test whether _linux is ignored.",
			args: args{
				builddir: "./testdata/buildcontext/",
				filename: "compile_linux.go",
			},
			want: false,
		},
		{
			name: "Test whether darwin is ignored.",
			args: args{
				builddir: "./testdata/buildcontext/",
				filename: "compile_darwin.go",
			},
			want: true,
		},
		{
			name: "Test whether _linux is ignored.",
			args: args{
				builddir: "./testdata/buildcontext/",
				filename: "compile_darwin_amd64.go",
			},
			want: true,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := IsIgnoredFileName(tt.args.builddir, tt.args.filename); got != tt.want {
				t.Errorf("IsIgnoredFileName() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestIsRestrictedDir(t *testing.T) {
	type args struct {
		dirname string
	}
	tests := []struct {
		name string
		args args
		want bool
	}{
		{
			name: "Test .git directory is ignored",
			args: args{
				dirname: ".git",
			},
			want: true,
		},
		{
			name: "Test tests directory is ignored",
			args: args{
				dirname: "test",
			},
			want: true,
		},
		{
			name: "Test a generic directory is not ignored",
			args: args{
				dirname: "lolnogenerics",
			},
			want: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := IsRestrictedDir(tt.args.dirname); got != tt.want {
				t.Errorf("IsRestrictedDir() = %v, want %v", got, tt.want)
			}
		})
	}
}
